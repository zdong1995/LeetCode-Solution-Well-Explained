# LeetCode-Solution-Well-Explained
[![](https://img.shields.io/badge/LeetCode-Solution-gree?logo=leetcode)](https://github.com/zdong1995/LeetCode-Solution-Well-Explained) ![java](https://img.shields.io/badge/Language-Java-orange?logo=java)

Solutions for my LeetCode using Java. Sorted in different topics and add detailed comments for easy understanding.

Welcome to check my repository [Algorithm-Interview](https://github.com/zdong1995/Algorithm-Interview) to prepare for algorithm interview. This repo consists of beginer-friendly tutorial of Data Structure and Algorithm, summary of classified algorithm questions, and notes for Java and Object Oriented Design.

If this is helpful for you, please feel free to add a star to the repo. Thank you! ❤️

# Problems and Solutions

| # | Title | Topic | Solution | Basic idea| Difficulty |
|---| ----- | ----- | -------- | --------------------- | ------ |
| 1 | [two-sum](https://leetcode.com/problems/two-sum) | HashTable |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/hashmap/two-sum.java) [Python](https://github.com/zdong1995/CrackingAlgorithms/blob/master/python/hashmap/two-sum.py)| One pass hashtable to check whether the complement in the map | Easy |
| 2 | [add-two-numbers](https://leetcode.com/problems/add-two-numbers) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/add-two-numbers.java)| Two pointers to sum by digit, be careful with last non-zero carry after sum all digits | Medium |
| 3 | [longest-substring-without-repeating-characters](https://leetcode.com/problems/longest-substring-without-repeating-characters) | Sliding Window | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/slidingWindow/longest-substring-without-repeating-characters.java)| Sliding window + HashTable counter to remove duplicates | Medium |
| 5 | [longest-palindromic-substring](https://leetcode.com/problems/longest-palindromic-substring) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/longest-palindromic-substring.java)| Expand from `2n - 1` possible centers | Medium |
| 7 | [reverse-integer](https://leetcode.com/problems/reverse-integer) | Other | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/other/reverse-integer.java)| Check overflow to return 0 | Easy |
| 15 | [3sum](https://leetcode.com/problems/3sum) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/3sum.java)| For loop + Two Pointer to search for 2 Sum pair | Medium |
| 16 | [3sum-closest](https://leetcode.com/problems/3sum-closest) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/3sum-closest.java)| Two pointers to search 2 Sum pair equal to `target - nums[i]`, maintain minDiff to determine closest | Medium |
| 17 | [letter-combinations-of-a-phone-number](https://leetcode.com/problems/letter-combinations-of-a-phone-number) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/letter-combinations-of-a-phone-number.java)| DFS + using dictionary to handle possible letters of current number representation | Medium |
| 18 | [4sum](https://leetcode.com/problems/4sum) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/4sum.java)| Two times 2 Sum, guarantee the index of two pairs should be `i1 < j1 < i2 < j2` to avoid duplicates | Medium |
| 19 | [remove-nth-node-from-end-of-list](https://leetcode.com/problems/remove-nth-node-from-end-of-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/remove-nth-node-from-end-of-list.java)| Two pointer to mainatain a gap with size = n | Medium |
| 21 | [merge-two-sorted-lists](https://leetcode.com/problems/merge-two-sorted-lists) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/merge-two-sorted-lists.java)| Maintain dummy head and tail to iteratively add smalled node to the end | Easy |
| 22 | [generate-parentheses](https://leetcode.com/problems/generate-parentheses) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/generate-parentheses.java)| Check number of left / right parentheses before DFS. | Medium |
| 23 | [merge-k-sorted-lists](https://leetcode.com/problems/merge-k-sorted-lists) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/merge-k-sorted-lists.java)| Use K-size min heap to compare k pointers to move the smallest node each time | Hard |
| 24 | [swap-nodes-in-pairs](https://leetcode.com/problems/swap-nodes-in-pairs) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/swap-nodes-in-pairs.java)| Recursion rule `swapPair(head.next.next)` | Medium |
| 25 | [reverse-nodes-in-k-group](https://leetcode.com/problems/reverse-nodes-in-k-group) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/reverse-nodes-in-k-group.java)| Find K-group, reverse K-group and link to next reversed sub-list. | Hard |
| 26 | [remove-duplicates-from-sorted-array](https://leetcode.com/problems/remove-duplicates-from-sorted-array) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/remove-duplicates-from-sorted-array.java)| Two pointers, slow is the last element to be returned. | Easy |
| 30 | [substring-with-concatenation-of-all-words](https://leetcode.com/problems/substring-with-concatenation-of-all-words) | Sliding Window | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/slidingWindow/substring-with-concatenation-of-all-words.java)| Sliding window with unit of word, use two Map to compare whether matched | Hard |
| 33 | [search-in-rotated-sorted-array](https://leetcode.com/problems/search-in-rotated-sorted-array) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/search-in-rotated-sorted-array.java)| Binary Search, each time we need to determine which part to search next, sorted or rotated sorted part | Medium |
| 34 | [find-first-and-last-position-of-element-in-sorted-array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/find-first-and-last-position-of-element-in-sorted-array.java)| Two times binary search to find start and end positions | Medium |
| 35 | [search-insert-position](https://leetcode.com/problems/search-insert-position) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/search-insert-position.java)| Find closest and insert at the next position or closest position | Easy |
| 39 | [combination-sum](https://leetcode.com/problems/combination-sum) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/combination-sum.java)| DFS each level represent how many we will select for each candidates | Medium |
| 40 | [combination-sum-ii](https://leetcode.com/problems/combination-sum-ii) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/combination-sum-ii.java)| Subsets II problem, find unique subsets that sums to target | Medium |
| 41 | [first-missing-positive](https://leetcode.com/problems/first-missing-positive) | Array | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/first-missing-positive.java)| For the index i, swap the number `nums[i]` to its correct position, i.e. `index = nums[i] - 1` | Hard |
| 42 | [trapping-rain-wate](https://leetcode.com/problems/trapping-rain-wate) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/trapping-rain-wate.java)| The water trapped at current index  = max water level - current height. The max water level is determine by minimum between left and right max height | Hard |
| 45 | [jump-game-ii](https://leetcode.com/problems/jump-game-ii) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/jump-game-ii.java)| Array to store the min jumps needed to reach end from i-th position | Hard |
| 46 | [permutations](https://leetcode.com/problems/permutations) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/permutations.java)| Use in-place swap or extra boolean array to mark used state. | Medium |
| 47 | [permutations-ii](https://leetcode.com/problems/permutations-ii) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/permutations-ii.java)| For each level, use HashSet to track whether letter has been used. | Medium |
| 48 | [rotate-image](https://leetcode.com/problems/rotate-image) | Matrix | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/matrix/rotate-image.java)| Recursion to replace left top -> right top -> right bottom -> left bottom | Medium |
| 49 | [group-anagrams](https://leetcode.com/problems/group-anagrams) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/group-anagrams.java)| Use count sort and hashmap to store each group of anagram | Medium |
| 50 | [powx-n](https://leetcode.com/problems/powx-n) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/powx-n.java)| Recursive `x^t = x^(t/2) * x^(t/2)` and be careful with `Interger.MIN_VALUE` | Medium |
| 53 | [maximum-subarray](https://leetcode.com/problems/maximum-subarray) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/maximum-subarray.java)| Max between (previous max_sum + current num) and only current num itself | Easy |
| 54 | [spiral-matrix](https://leetcode.com/problems/spiral-matrix) | Matrix | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/matrix/spiral-matrix.java)| Iterative to traverse from top -> right -> bottom -> left, update begin index and end after each iteration | Medium |
| 55 | [jump-game](https://leetcode.com/problems/jump-game) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/jump-game.java)| Boolean array to store whether we can jump starting from current index to reach the end | Medium |
| 59 | [spiral-matrix-ii](https://leetcode.com/problems/spiral-matrix-ii) | Matrix | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/matrix/spiral-matrix-ii.java)| Recursion to fill matrix layer by layer, top row -> right col -> bottom row -> left col | Medium | Medium |
| 61 | [rotate-list](https://leetcode.com/problems/rotate-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/rotate-list.java)| Find last (k % len + 1) node as newTail, reconnect list | Medium |
| 62 | [unique-paths](https://leetcode.com/problems/unique-paths) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/unique-paths.java)| Paths = paths from left + paths from right | Medium |
| 70 | [climbing-stairs](https://leetcode.com/problems/climbing-stairs) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/climbing-stairs.java)| ways to climb to i-th level = ways to climb to (i-1)th level + (i-2)th level | Easy |
| 72 | [edit-distance](https://leetcode.com/problems/edit-distance) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/edit-distance.java)| 2D array represent distance between two substring | Hard |
| 74 | [search-a-2d-matrix](https://leetcode.com/problems/search-a-2d-matrix) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/search-a-2d-matrix.java)| 2D array to 1D array, Binary Search | Medium |
| 75 | [sort-colors](https://leetcode.com/problems/sort-colors) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/sort-colors.java)| Maintain 3 pointers to partition to 3 areas | Medium |
| 76 | [minimum-window-substring](https://leetcode.com/problems/minimum-window-substring) | Sliding Window | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/slidingWindow/minimum-window-substring.java)| Maintain HashMap as counter of letters needed to match and update numToMatch when sliding the window | Hard |
| 77 | [combinations](https://leetcode.com/problems/combinations) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/combinations.java)| Similar to all subsets, n levels recursion, base case need check `size == k`? | Medium |
| 78 | [subsets](https://leetcode.com/problems/subsets) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/subsets.java)| For each level, two state: add to subset or not. Recursion tree will have `num.length` levels. | Medium |
| 80 | [remove-duplicates-from-sorted-array-ii](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/remove-duplicates-from-sorted-array-ii.java)| Two pointers, each time check fast and (slow - 2) | Medium |
| 83 | [remove-duplicates-from-sorted-list](https://leetcode.com/problems/remove-duplicates-from-sorted-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/remove-duplicates-from-sorted-list.java)| Iterative and recursive way to check duplicate and remove node | Easy |
| 84 | [largest-rectangle-in-histogram](https://leetcode.com/problems/largest-rectangle-in-histogram) | Stack | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/stack/largest-rectangle-in-histogram.java)| Use one monotonic ascending stack to record the increasing sequencet. For the rectangle with height = current bar height: left bound is the index of previous bar in the stack, right bound is the index of first bar that smaller than stack top | Hard |
| 86 | [partition-list](https://leetcode.com/problems/partition-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/partition-list.java)| Maintain two Dummy head and tail for small and large list, then concatenate | Medium |
| 88 | [merge-sorted-array](https://leetcode.com/problems/merge-sorted-array) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/merge-sorted-array.java)| In-place: two pointer from end to start, iteratively copy larger number to the end | Easy |
| 90 | [subsets-ii](https://leetcode.com/problems/subsets-ii) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/subsets-ii.java)| Add element or not add element. If not add, skip all the rest duplicates. | Medium |
| 92 | [reverse-linked-list-ii](https://leetcode.com/problems/reverse-linked-list-ii) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/reverse-linked-list-ii.java)| Find m-th node and record tail, reverse and connect 3 parts | Medium |
| 93 | [restore-ip-addresses](https://leetcode.com/problems/restore-ip-addresses) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/restore-ip-address.java)| DFS with 3 branch, 4 level recursion tree, pruning for leading zero cases | Medium |
| 100 | [same-tree](https://leetcode.com/problems/same-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/same-tree.java)| Recursive compare `LL` & `RL`, `LR` & `RR` to determine whether is same tree for each pair | Easy |
| 101 | [symmetric-tree](https://leetcode.com/problems/symmetric-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/symmetric-tree.java)| Recursive compare `LL` & `RR`, `LR` & `RL` to determine whether symmetric for each pair | Easy |
| 102 | [binary-tree-level-order-traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/binary-tree-level-order-traversal.java)| BFS, use list to store value on each level | Medium |
| 103 | [binary-tree-zigzag-level-order-traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/binary-tree-zigzag-level-order-traversal.java)| Use Deque to BFS and offerFirst/Last for odd/even layer respectively | Medium |
| 104 | [maximum-depth-of-binary-tree](https://leetcode.com/problems/maximum-depth-of-binary-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/maximum-depth-of-binary-tree.java)| Recursion to get max height from left and right child then increase by 1| Easy |
| 105 | [construct-binary-tree-from-preorder-and-inorder-traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/construct-binary-tree-from-preorder-and-inorder-traversal.java)| Find root from first position from pre-order array and find the index in in-order, to get the size of left subtree. Recursively build left subtree and left subtree | Medium |
| 106 | [construct-binary-tree-from-inorder-and-postorder-traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/construct-binary-tree-from-inorder-and-postorder-traversal.java)| Find root from last position from pre-order array and find the index in in-order, to get the size of left subtree. Recursively build left subtree and left subtree | Medium |
| 110 | [balanced-binary-tree](https://leetcode.com/problems/balanced-binary-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/balanced-binary-tree.java)| Pre-order traverse and compare left & right using `getHeight()` helper function | Easy |
| 114 | [flatten-binary-tree-to-linked-list](https://leetcode.com/problems/flatten-binary-tree-to-linked-list) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/flatten-binary-tree-to-linked-list.java)| Flatten left and right, then connect the tail of left to first node of right | Medium |
| 116 | [populating-next-right-pointers-in-each-node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/populating-next-right-pointers-in-each-node.java)| Recursion or Iterative. Traverse the leftmost path, for each starting node, traverse the level using next pointer, to build next pointers for the next level | Medium |
| 117 | [populating-next-right-pointers-in-each-node-ii](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/populating-next-right-pointers-in-each-node-ii.java)| BFS to level-order traversal. For each level, connect the current polled out node to the first node in the queue | Medium |
| 124 | [binary-tree-maximum-path-sum](https://leetcode.com/problems/binary-tree-maximum-path-sum) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/binary-tree-maximum-path-sum.java)| For each node get path sum of left and right child. Update global max and return the larger path | Hard |
| 125 | [valid-palindrome](https://leetcode.com/problems/valid-palindrome) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/valid-palindrome.java)| Two pointers from left and right to compare digits and chars | Easy |
| 127 | [word-ladder](https://leetcode.com/problems/word-ladder) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/word-ladder.java)| BFS starting from beginWord, each time check whether neighbor word in the dict, return shortest length once meet the endWord | Medium |
| 128 | [longest-consecutive-sequence](https://leetcode.com/problems/longest-consecutive-sequence) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/longest-consecutive-sequence.java)| Use set to speed up search process, for each number in the array, use as a center of sequence, and expand to left and right to find the longest length | Hard |
| 133 | [clone-graph](https://leetcode.com/problems/clone-graph) | Graph | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/graph/clone-graph.java)| DFS + Map to store 1:1 mapping of original node and copied node | Medium |
| 136 | [single-number](https://leetcode.com/problems/single-number) | Bits Manipulation | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bitsManipulation/single-number.java)| `a XOR a = 0` thus XOR all the elements and the duplicates will cancel to 0, only single number left | Easy |
| 137 | [single-number-ii](https://leetcode.com/problems/single-number-ii) | Bits Manipulation | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bitsManipulation/single-number-ii.java)| For each bits, find the number of 1 bits and mod 3 to find whether the current bit of single number is 1 | Medium |
| 138 | [copy-list-with-random-pointer](https://leetcode.com/problems/copy-list-with-random-pointer) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/copy-list-with-random-pointer.java)| Maintain 1 to 1 mapping from orignal node to copied node to avoid duplicate copy | Medium |
| 139 | [word-break](https://leetcode.com/problems/word-break) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/word-break.java)| DP table to store whether the substring [0, i) can break | Medium |
| 141 | [linked-list-cycle](https://leetcode.com/problems/linked-list-cycle) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/linked-list-cycle.java)| Fast and slow pointer, cycle exists when two pointers meet | Easy |
| 143 | [reorder-list](https://leetcode.com/problems/reorder-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/reorder-list.java)| Find mid nodes -> Reverse second part -> Merge two parts | Medium |
| 144 | [binary-tree-preorder-traversal](https://leetcode.com/problems/binary-tree-preorder-traversal) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/binary-tree-preorder-traversal.java)| Recursion + Iterative by explicitly maintain a stack | Medium |
| 147 | [insertion-sort-list](https://leetcode.com/problems/insertion-sort-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/insertion-sort-list.java)| Use dummy node, each time find the last position that is smaller than current node, then insert current to that position | Medium |
| 151 | [reverse-words-in-a-string](https://leetcode.com/problems/reverse-words-in-a-string) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/reverse-words-in-a-string.java)| 3-steps reverse and remove space | Medium |
| 153 | [find-minimum-in-rotated-sorted-array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/find-minimum-in-rotated-sorted-array.java)| Find the first element that <= last element | Medium |
| 155 | [min-stack](https://leetcode.com/problems/min-stack) | Stack | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/stack/min-stack.java)| Auxiliary sync stack to store min, push min when num <= min | Easy |
| 156 | [binary-tree-upside-down](https://leetcode.com/problems/binary-tree-upside-down) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/binary-tree-upside-down.java)| Subproblem: Reverse tree with root of `curRoot.left` | Medium |
| 159 | [longest-substring-with-at-most-two-distinct-characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters) | Sliding Window | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/slidingWindow/longest-substring-with-at-most-two-distinct-characters.java)| Sliding window and maintain HashMap with count representing types of unique characters in current window | Medium |
| 160 | [intersection-of-two-linked-lists](https://leetcode.com/problems/intersection-of-two-linked-lists) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/intersection-of-two-linked-lists.java)| Get length of two linkedlist, move the shorter one by diff length, use two pointers to find the intersection | Easy |
| 167 | [two-sum-ii-input-array-is-sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/two-sum-ii-input-array-is-sorted.java)| Two pointers from left and right | Easy |
| 170 | [two-sum-iii-data-structure-design](https://leetcode.com/problems/two-sum-iii-data-structure-design) | Design | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/design/two-sum-iii-data-structure-design.java)| Add: put to HashMap -> O(1), Find: iterate each key in HashMap and find 2 sum -> O(N) | Easy |
| 186 | [reverse-words-in-a-string-ii](https://leetcode.com/problems/reverse-words-in-a-string-ii) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/reverse-words-in-a-string-ii.java)| 3-steps reverse: reverse all words, then reverse whole sentence | Medium |
| 189 | [rotate-array](https://leetcode.com/problems/rotate-array) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/rotate-array.java)| 3-steps reverse, first part ending at (length - 1 - steps). | Easy |
| 190 | [reverse-bits](https://leetcode.com/problems/reverse-bits) | Bits Manipulation | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bitsManipulation/reverse-bits.java)| swap left and right by using left shifted mask | Easy |
| 191 | [number-of-1-bits](https://leetcode.com/problems/number-of-1-bits) | Bits Manipulation | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bitsManipulation/number-of-1-bits.java)| Iteratively right shift and compare `n & 1` with 1 | Easy |
| 199 | [binary-tree-right-side-view](https://leetcode.com/problems/binary-tree-right-side-view) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/binary-tree-right-side-view.java)| DFS: traverse root -> right -> and record the first node reaching level i. BFS: level order traverse + record last node in current level | Medium |
| 200 | [number-of-islands](https://leetcode.com/problems/number-of-islands) | Graph | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/graph/number-of-islands.java)| BFS/DFS Traverse each grid and mark visited | Medium |
| 203 | [remove-linked-list-elements](https://leetcode.com/problems/remove-linked-list-elements) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/remove-linked-list-elements.java)| Dummy node, iteratively remove all target | Easy |
| 206 | [reverse-linked-list](https://leetcode.com/problems/reverse-linked-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/reverse-linked-list.java)| Iterative and Recursion | Easy |
| 209 | [minimum-size-subarray-sum](https://leetcode.com/problems/minimum-size-subarray-sum) | Array | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/minimum-size-subarray-sum.java)| Sliding window, shrink subarray window when sum >= s | Medium |
| 215 | [kth-largest-element-in-an-array](https://leetcode.com/problems/kth-largest-element-in-an-array) | Heap | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/heap/kth-largest-element-in-an-array.java)| MinHeap with size k / MaxHeap with size n / Quick Selection | Medium |
| 216 | [combination-sum-iii](https://leetcode.com/problems/combination-sum-iii) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/combination-sum-iii.java)| Find `k` size subsets from `[1,2,3,4,5,6,7,8,9]` that sums to `n` | Medium |
| 226 | [invert-binary-tree](https://leetcode.com/problems/invert-binary-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/invert-binary-tree.java)| Pre-order/Post-order recursion/iterative or level-order iterative to traverse the tree to invert left and right | Easy |
| 231 | [power-of-two](https://leetcode.com/problems/power-of-two) | Bits Manipulation | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bitsManipulation/power-of-two.java)| Check whether contain only one 1-bit | Easy |
| 234 | [palindrome-linked-list](https://leetcode.com/problems/palindrome-linked-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/palindrome-linked-list.java)| Find mid -> reverse 2nd half -> check palindrome | Easy |
| 235 | [lowest-common-ancestor-of-a-binary-search-tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/lowest-common-ancestor-of-a-binary-search-tree.java)| If root.val is between p.val and q.val, then root is the LCA | Easy |
| 236 | [lowest-common-ancestor-of-a-binary-tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/lowest-common-ancestor-of-a-binary-tree.java)| For each level, return root when find p and q in the left or right subtree, otherwise, return left child or right child that is p or q | Medium |
| 237 | [delete-node-in-a-linked-list](https://leetcode.com/problems/delete-node-in-a-linked-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/delete-node-in-a-linked-list.java)| Replace current node to next node, then delete next node to mimic deleting current node | Easy |
| 240 | [search-a-2d-matrix-ii](https://leetcode.com/problems/search-a-2d-matrix-ii) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/search-a-2d-matrix-ii.java)| Binary Search starting from the left bottom corner, find the largest smaller than target to search right side of row, find the first larger than target to search upside of col | Medium |
| 242 | [valid-anagram](https://leetcode.com/problems/valid-anagram) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/valid-anagram.java)| Increase count when traverse source string, while decrease for target. Check whether negative count exists | Easy |
| 254 | [factor-combinations](https://leetcode.com/problems/factor-combinations) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/factor-combinations.java)| Find all factors and backtracking similar to coin change | Medium |
| 259 | [3sum-smaller](https://leetcode.com/problems/3sum-smaller) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/3sum-smaller.java)| Fix one number, use Two Pointers to run 2 sum smaller | Medium |
| 268 | [missing-number](https://leetcode.com/problems/missing-number) | Bits Manipulation | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bitsManipulation/missing-number.java)| XOR all the numbers | Easy |
| 283 | [move-zeroes](https://leetcode.com/problems/move-zeroes) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/move-zeroes.java)| 2 pointers copy non-0s to front of left, then fill left to end with 0s. | Easy |
| 286 | [walls-and-gates](https://leetcode.com/problems/walls-and-gates) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/walls-and-gates.java)| Starting from all the GATEs, using BFS to expand circle to update shortest distance to each `INF` | Medium |
| 317 | [shortest-distance-from-all-buildings](https://leetcode.com/problems/shortest-distance-from-all-buildings) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/shortest-distance-from-all-buildings.java)| Run BFS starting from each building to update cost to each land, exclude unreachable lands each time to speed up the search algorithm | Hard |
| 322 | [coin-change](https://leetcode.com/problems/coin-change) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/coin-change.java)| `DP[i] = DP[i - coin] + 1`, represent number of coins needed to change | Medium |
| 328 | [odd-even-linked-list](https://leetcode.com/problems/odd-even-linked-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/odd-even-linked-list.java)| Similar to partition linkedlist, use index to determine odd or even | Medium |
| 340 | [longest-substring-with-at-most-k-distinct-characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters) | Sliding Window | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/slidingWindow/longest-substring-with-at-most-k-distinct-characters.java)| Sliding window and maintain HashMap with count representing types of unique characters in current window | Medium |
| 344 | [reverse-string](https://leetcode.com/problems/reverse-string) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/reverse-string.java)| Two pointers swap or Recursion | Easy |
| 347 | [top-k-frequent-elements](https://leetcode.com/problems/top-k-frequent-elements) | Heap | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/heap/top-k-frequent-elements.java)| HashMap for counter, MinHeap to scan the whole keys of counter | Medium |
| 374 | [guess-number-higher-or-lower](https://leetcode.com/problems/guess-number-higher-or-lower) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/guess-number-higher-or-lower.java)| Classical binary search | Easy |
| 378 | [kth-smallest-element-in-a-sorted-matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/kth-smallest-element-in-a-sorted-matrix.java)| Best First Search, initial at `[0][0]`, expand each node to generate `[x+1][y]` and `[x][y+1]` | Medium |
| 387 | [first-unique-character-in-a-string](https://leetcode.com/problems/first-unique-character-in-a-string) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/first-unique-character-in-a-string.java)| HashMap to store counter and one pass to find first character with count = 1 | Easy |
| 394 | [decode-string](https://leetcode.com/problems/decode-string) | Stack | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/stack/decode-string.java)| 2 stack for count and cur string, decode when meet `"]"` | Medium |
| 409 | [longest-palindrome](https://leetcode.com/problems/longest-palindrome) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/longest-palindrome.java)| HashMap/Set/Array to store count and then find the number of characters appeared odd times | Easy |
| 417 | [pacific-atlantic-water-flow](https://leetcode.com/problems/pacific-atlantic-water-flow) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/pacific-atlantic-water-flow.java)| Two BFS starting from Pacific and Atlantic ocean to find reachable cells, find the overlap will be the result | Medium |
| 419 | [partition-equal-subset-sum](https://leetcode.com/problems/partition-equal-subset-sum) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/partition-equal-subset-sum.java)| All Subsets similar DFS + Memoization | Medium |
| 430 | [flatten-a-multilevel-doubly-linked-list](https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/flatten-a-multilevel-doubly-linked-list.java)| For each node that has child, traverse child list to find tail and connect | Medium |
| 433 | [minimum-genetic-mutation](https://leetcode.com/problems/minimum-genetic-mutation) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/minimum-genetic-mutation.java)| BFS to search the shortest length from begin to end, the result should be `length - 1`  | Medium |
| 438 | [find-all-anagrams-in-a-string](https://leetcode.com/problems/find-all-anagrams-in-a-string) | Sliding Window | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/slidingWindow/find-all-anagrams-in-a-string.java)| Sliding window and maintain hashmap to count the number of letters needed to match. When satisfied, check window length == target length and add to result | Medium |
| 443 | [string-compression](https://leetcode.com/problems/string-compression) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/string-compression.java)| Slow and fast pointers to read and copy chars and counts | Easy |
| 461 | [hamming-distance](https://leetcode.com/problems/hamming-distance) | Bits Manipulation | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bitsManipulation/hamming-distance.java)| XOR the two Interger and count how many 1-bits | Easy |
| 509 | [fibonacci-number](https://leetcode.com/problems/fibonacci-number) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/fibonacci-number.java)| 2-value Memoization `fibo(N) = fibo(N-2) + fibo(N-1)` | Easy |
| 542 | [01-matrix](https://leetcode.com/problems/01-matrix) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/01-matrix.java)| Starting from each 0 to find the shortest distance to 1 | Medium |
| 554 | [brick-wall](https://leetcode.com/problems/brick-wall) | HashTable |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/hashmap/brick-wall.java)| Use hashtable to counter the number of bricks at each length as edge. Use prefix sum to find the edge position | Medium |
| 572 | [subtree-of-another-tree](https://leetcode.com/problems/subtree-of-another-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/subtree-of-another-tree.java)| Traverse the tree to check whether the subtree at each node are the same tree as target tree | Easy |
| 611 | [valid-triangle-number](https://leetcode.com/problems/valid-triangle-number) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/valid-triangle-number.java)| Fix long side and number of two sum pairs that larger than the longer side | Medium |
| 617 | [merge-two-binary-trees](https://leetcode.com/problems/merge-two-binary-trees) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/merge-two-binary-trees.java)| Recursion to merge left and right to connect to current root | Easy |
| 643 | [maximum-average-subarray-i](https://leetcode.com/problems/maximum-average-subarray-i) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/maximum-average-subarray-i.java)| Sliding window to find the maximum sum with size K | Easy |
| 647 | [palindromic-substrings](https://leetcode.com/problems/palindromic-substrings) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/palindromic-substrings.java)| Expand from each possbile centers | Medium |
| 653 | [two-sum-iv-input-is-a-bst](https://leetcode.com/problems/two-sum-iv-input-is-a-bst) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/two-sum-iv-input-is-a-bst.java)| Maintain a set to record the seen elements during traverse, check whether complement of current root in set | Easy |
| 654 | [maximum-binary-tree](https://leetcode.com/problems/maximum-binary-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/maximum-binary-tree.java)| Scan `[left, right]` each time to find the maximum value and index to build root, then recursively build left subtree in `[left, rootIdx - 1]` and right subtree in `[rootIdx + 1, right]` | Medium |
| 658 | [find-k-closest-elements](https://leetcode.com/problems/find-k-closest-elements) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/find-k-closest-elements.java)| Find closest and expand to both sides | Medium |
| 674 | [longest-continuous-increasing-subsequence](https://leetcode.com/problems/longest-continuous-increasing-subsequence) | DP |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dp/longest-continuous-increasing-subsequence.java)| `dp[i]` represents the longest increasing subarray in `[0, i]`, increment by 1 when still ascending, otherwise reset current dp to 1 | Easy |
| 680 | [valid-palindrome-ii](https://leetcode.com/problems/valid-palindrome-ii) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/valid-palindrome-ii.java)| Two Pointers, if character at left and right are different, check whether remove-left or remove-right is palindrome | Easy |
| 692 | [top-k-frequent-words](https://leetcode.com/problems/top-k-frequent-words) | Heap | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/heap/top-k-frequent-words.java)| Use HashMap to count the frequency and use maxHeap to poll top K | Medium |
| 694 | [number-of-distinct-islands](https://leetcode.com/problems/number-of-distinct-islands) | Graph | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/graph/number-of-distinct-islands.java)| DFS to find the islands and record the direction path string, in order to discriminate islands | Medium |
| 695 | [max-area-of-island](https://leetcode.com/problems/max-area-of-island) | Graph | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/graph/max-area-of-island.java)| DFS to search the area through four direction and return the sum to obtain area of island | Medium |
| 698 | [partition-to-k-equal-sum-subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets) | DFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/dfs/partition-to-k-equal-sum-subsets.java)| Repeatedly DFS k times to find K subsets with sum equal to SUM/K | Medium |
| 700 | [search-in-a-binary-search-tree](https://leetcode.com/problems/search-in-a-binary-search-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/search-in-a-binary-search-tree.java)| Iterative and Recursive | Easy |
| 702 | [search-in-a-sorted-array-of-unknown-size](https://leetcode.com/problems/search-in-a-sorted-array-of-unknown-size) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/search-in-a-sorted-array-of-unknown-size.java)| Reversely run binary search to find the right bound, then classical binary search | Medium |
| 703 | [kth-largest-element-in-a-stream](https://leetcode.com/problems/kth-largest-element-in-a-stream) | Heap | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/heap/kth-largest-element-in-a-stream.java)| Maitan a minHeap to scan the whole stream. If new elment > peek, poll and offer new element. | Easy |
| 704 | [binary-search](https://leetcode.com/problems/binary-search) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/binary-search.java)| Classical Binary Search | Easy |
| 724 | [find-pivot-index](https://leetcode.com/problems/find-pivot-index) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/find-pivot-index.java)| Increase prefix sum to reach half of total sum | Easy |
| 744 | [find-smallest-letter-greater-than-target](https://leetcode.com/problems/find-smallest-letter-greater-than-target) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/find-smallest-letter-greater-than-target.java)| Find first element that larger than target | Easy |
| 763 | [partition-labels](https://leetcode.com/problems/partition-labels) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/partition-labels.java)| One pass to record the last index of each character. Two pointers to scan the string, extend current partition when met new character. | Medium |
| 780 | [reaching-points](https://leetcode.com/problems/reaching-points) | Other | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/other/reaching-points.java)| Reverse backtracking to consider two operations recursively | Hard |
| 785 | [is-graph-bipartite](https://leetcode.com/problems/is-graph-bipartite) | Graph | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/graph/is-graph-bipartite.java)| BFS each node and color the node, if current node and neighbors have same color, return false | Medium |
| 786 | [k-th-smallest-prime-fraction](https://leetcode.com/problems/k-th-smallest-prime-fraction) | Heap | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/heap/k-th-smallest-prime-fraction.java)| Implicit fraction matrix composed by given sorted array. Use heap to find K-th smallest. | Hard |
| 819 | [most-common-word](https://leetcode.com/problems/most-common-word) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/most-common-word.java)| One pass to manipulate the char array to maintain the max counter string | Easy |
| 876 | [middle-of-the-linked-list](https://leetcode.com/problems/middle-of-the-linked-list/) | LinkedList | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/linkedlist/middle-of-the-linked-list.java)| Fast & Slow two pointers | Easy |
| 889 | [construct-binary-tree-from-preorder-and-postorder-traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/construct-binary-tree-from-preorder-and-postorder-traversal.java)| Find root and left subtree root from 1st and 2nd in pre-order sequence, get the left size and recursively construct left and right subtree | Medium |
| 895 | [maximum-frequency-stack](https://leetcode.com/problems/maximum-frequency-stack) | Design | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/design/maximum-frequency-stack.java)| Use one map to maintain the frequency for each element, use another map to map each frequency to a stack containing all element with the same frequency, update `maxFreq` if applicable | Hard |
| 905 | [sort-array-by-parity](https://leetcode.com/problems/sort-array-by-parity) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/sort-array-by-parity.java)| Left and Right pointer, swap when left is odd and right is even | Easy |
| 912 | [merge-sort](https://leetcode.com/problems/sort-an-array) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/merge-sort.java)| Recursion helper function + merge two sorted array | Medium |
| 912 | [quick-sort](https://leetcode.com/problems/sort-an-array) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/quick-sort.java)| Pick random pivot + maintain two pointer to partion the array |  Medium |
| 912 | [selection-sort](https://leetcode.com/problems/sort-an-array) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/selection-sort.java)| Maintain one partition between sorted part and unsorted part |  Medium |
| 951 | [flip-equivalent-binary-trees](https://leetcode.com/problems/flip-equivalent-binary-trees) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/flip-equivalent-binary-trees.java)| Recursively check each subtree is symmetric tree or identical tree | Medium |
| 958 | [check-completeness-of-a-binary-tree](https://leetcode.com/problems/check-completeness-of-a-binary-tree) | BFS | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/bfs/check-completeness-of-a-binary-tree.java)| BFS level order traversal, add one bool to indicate whether null found in the leftside | Medium |
| 973 | [k-closest-points-to-origin](https://leetcode.com/problems/k-closest-points-to-origin) | Heap | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/heap/k-closest-points-to-origin.java)| maxHeap to scan the point list | Medium |
| 981 | [time-based-key-value-store](https://leetcode.com/problems/time-based-key-value-store) | HashTable |[Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/hashmap/time-based-key-value-store.java)| Use TreeMap to keep order of timestamp for value of each key | Medium |
| 1010 | [pairs-of-songs-with-total-durations-divisible-by-60](https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60) | Array | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/pairs-of-songs-with-total-durations-divisible-by-60.java)| 2 Sum to find the number of remainder (time % 60) pairs that sums to 60 | Medium |
| 1047 | [remove-all-adjacent-duplicates-in-string](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/remove-all-adjacent-duplicates-in-string.java)| Two pointer to maintian one in-place stack. | Easy |
| 1089 | [duplicate-zeroes](https://leetcode.com/problems/duplicate-zeroes) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/duplicate-zeroes.java)| One pass count zeroes, then two pointers from right to left to copy elements | Easy |
| 1120 | [maximum-average-subtree](https://leetcode.com/problems/maximum-average-subtree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/maximum-average-subtree.java)| Each left get subtree sum and node number from left and right child, then calculate average and update global max | Medium |
| 1209 | [remove-all-adjacent-duplicates-in-string-ii](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/remove-all-adjacent-duplicates-in-string-ii.java)| Count array + fast/slow pointers implicitly mainatain as stack to pop k duplicates | Medium |
| 1396 | [design-underground-system](https://leetcode.com/problems/design-underground-system) | Design | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/design/design-underground-system.java)| Two HashMap for user-checkin and routes-time | Medium |
| 1428 | [leftmost-column-with-at-least-a-one](https://leetcode.com/problems/leftmost-column-with-at-least-a-one) | Matrix | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/matrix/leftmost-column-with-at-least-a-one.java)| Startign from bottom right, search left we met 1 to find leftmost 1, search up when met 0 | Medium |
| 1608 | [special-array-with-x-elements-greater-than-or-equal-x](https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/special-array-with-x-elements-greater-than-or-equal-x.java)| Binary Search to find the first position `nums[i] >= len - i` and `nums[i - 1] < len - u` | Easy |
| 1644 | [lowest-common-ancestor-of-a-binary-tree-ii](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/lowest-common-ancestor-of-a-binary-tree-ii.java)| If LCA is `p`, we need to check whether `q` appeared in the subtree of `p`, vice versa | Medium |
| 1650 | [lowest-common-ancestor-of-a-binary-tree-iii](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/lowest-common-ancestor-of-a-binary-tree-iii.java)| Find intersection of two linkedlist, `parent` is like `next` pointer | Medium |
| 1662 | [check-if-two-string-arrays-are-equivalent](https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/check-if-two-string-arrays-are-equivalent.java)| Two pointers to move across different strings, move string index when char index reach end | Easy |
| 1663 | [smallest-string-with-a-given-numeric-value](https://leetcode.com/problems/smallest-string-with-a-given-numeric-value) | Array | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/smallest-string-with-a-given-numeric-value.java)| Greedy to make left side as small as possbile, thus rightside should be as large as possbile | Medium |
| 1664 | [ways-to-make-a-fair-array](https://leetcode.com/problems/ways-to-make-a-fair-array) | Array | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/ways-to-make-a-fair-array.java)| After remove `nums[i]`, the even sum at right of `i` will become odd sum and the odd sum at right of `i`  will become even sum | Medium |
| L8 | [rotate-string](https://www.lintcode.com/problem/rotate-string) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/rotate-string.java)| 3 steps reverse, divided by index `str.length - 1 - offset` | Easy |
| L11 | [search-range-in-binary-search-tree](https://www.lintcode.com/problem/search-range-in-binary-search-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/search-range-in-binary-search-tree.java)| inOrder traverse and check bound condition before recurse left or right | Medium |
| L14 | [first-position-of-target](https://lintcode.com/problem/first-position-of-target) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/first-position-of-target.java)| Classical binary search + `right = mid` when found target to search left-side + post-processing | Easy |
| L39 | [recover-rotated-sorted-array](https://www.lintcode.com/problem/recover-rotated-sorted-array) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/recover-rotated-sorted-array.java)| 3 Steps reverse. One pass to find offset | Easy |
| L229 | [stack-sorting](https://www.lintcode.com/problem/stack-sorting/) | Array| [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/array/stack-sorting.java)| Selection sort. Bottom of buffer stack are sorted elements. | Medium |
| L443 | [two-sum-greater-than-target](https://www.lintcode.com/problem/two-sum-greater-than-target) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/two-sum-greater-than-target.java)| Two Pointer, count pairs when `left + right > target` | Medium |
| L458 | [last-position-of-target](https://lintcode.com/problem/last-position-of-target) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/last-position-of-target.java)| Classical binary search + `left = mid` when found target to search right-side + post-processing | Easy |
| L459 | [closest-number-in-sorted-array](https://www.lintcode.com/problem/closest-number-in-sorted-array) | Binary Search | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/binarySearch/closest-number-in-sorted-array.java)| Classical binary search + post-processing to compare distance from left/right to target | Easy |
| L470 | [tweaked-identical-binary-tree](https://www.lintcode.com/problem/tweaked-identical-binary-tree) | Tree | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/tree/tweaked-identical-binary-tree.java)| Recursion check whether is symmetric or same tree | Medium |
| L533 | [two-sum-closest-to-target](https://www.lintcode.com/problem/two-sum-closest-to-target) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/two-sum-closest-to-target.java)| Two pointers and update minDiff each time | Medium |
| L587 | [two-sum-unique-pairs](https://www.lintcode.com/problem/two-sum-unique-pairs) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/two-sum-unique-pairs.java)| Sort + Two Pointers, need to skip duplicate number | Medium |
| L609 | [two-sum-less-than-or-equal-to-target](https://www.lintcode.com/problem/two-sum-less-than-or-equal-to-target) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/two-sum-less-than-or-equal-to-target.java)| Two Pointer, count pairs when `left + right <= target` | Medium |
| L610 | [two-sum-difference-equals-to-target](https://lintcode.com/problem/two-sum-difference-equals-to-target) | Two Pointers | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/twoPointers/two-sum-difference-equals-to-target.java)| Two pointer sliding window and make sure `left < right` | Medium |
| L686 | [remove-arbitrary-space](https://www.lintcode.com/problem/remove-arbitrary-space) | String | [Java](https://github.com/zdong1995/CrackingAlgorithms/blob/master/java/string/remove-arbitrary-space.java)| Two pointers to copy non-space chars to slow position. Add heading space to non-first words. | Easy |